/*** RED5 Open Source Flash Server - http://www.osflash.org/red5** Copyright (c) 2006-2009 by respective authors (see below). All rights reserved.** This library is free software; you can redistribute it and/or modify it under the* terms of the GNU Lesser General Public License as published by the Free Software* Foundation; either version 2.1 of the License, or (at your option) any later* version.** This library is distributed in the hope that it will be useful, but WITHOUT ANY* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A* PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.** You should have received a copy of the GNU Lesser General Public License along* with this library; if not, write to the Free Software Foundation, Inc.,* 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA*/// ** AUTO-UI IMPORT STATEMENTS **//import com.metaliq.controls.ColorPicker;import mx.controls.TextInput;import org.red5.ui.controls.IconButton;import mx.controls.TextArea;// ** END AUTO-UI IMPORT STATEMENTS **import com.blitzagency.xray.util.XrayLoader;import org.red5.samples.livestream.videoconference.Connection;import org.red5.samples.livestream.videoconference.GlobalObject;import org.red5.samples.livestream.videoconference.TextFilter;import com.blitzagency.util.LSOUserPreferences;import org.red5.utils.Delegate;import flash.external.*;import com.gskinner.events.GDispatcher;class org.red5.samples.livestream.videoconference.Chat extends MovieClip {// Constants:	public static var CLASS_REF = org.red5.samples.livestream.videoconference.Chat;	public static var LINKAGE_ID:String = "org.red5.samples.livestream.videoconference.Chat";// Public Properties:	public var connection:Connection;	public var addEventListener:Function	public var removeEventListener:Function// Private Properties:	private var dispatchEvent:Function	private var connected:Boolean;	private var so:GlobalObject;	private var history:Array;	private var chatID:String;	private var defaultUserName:String = "Looser User"    private var streamID:Number;	private var si:Number;	private var snd:Sound;	private var sndTarget:MovieClip;	private var muted:Boolean = false;	private var soundMute:IconButton;	private var soundPlay:IconButton;	public static var red5URI = "rtmp://192.168.0.5/fitcDemo";// UI Elements:// ** AUTO-UI ELEMENTS **	private var chatBody:TextArea;	private var clearChat:IconButton;	private var message:TextInput;	private var userName:TextInput;// ** END AUTO-UI ELEMENTS **// Initialization:		private function Chat() {		GDispatcher.initialize(this);	    XrayLoader.addEventListener("LoadComplete", this, "xrayLoadComplete"); 	    XrayLoader.loadConnector("xrayconnector.swf");    }	private function onLoad():Void 	{ 		configUI(); 	}		private function xrayLoadComplete():Void	{		var xr = _global.com.blitzagency.xray.XrayTrace.getInstance();		xr.addEventListener("onTrace", this);	}			private function onTrace(traceInfo):Void	{      ExternalInterface.call("trace", traceInfo.sInfo);		}	// Public Methods:		public function getNames():Void	{		// should put out a call to all connected to update the names		so.sendGetNames();	}// Semi-Private Methods:// Private Methods:	public function configUI():Void 	{		streamID = Number(_level0.streamName.split("_")[1]);        _global.tt("Chat: Stream id is " + streamID);		chatID = "videoConferenceChat";						userName.addEventListener("change", Delegate.create(this, userNameChange));				// instantiate history object		history = new Array();				// add key listener for enter key		Key.addListener(this);				// create GlobalObject		so = new GlobalObject();		so.addEventListener("onNewMessage", Delegate.create(this, newMessageHandler));		so.addEventListener("onNewName", Delegate.create(this, newNameHandler));		so.addEventListener("onGetName", Delegate.create(this, getNameHandler));		//so.so.newMessage = Delegate.create(this, newMessageHandler);		//_global.tt("newMessage created?", so.so.newMessage);		// add listener for sync events		so.addEventListener("onSync", Delegate.create(this, onSyncHandler));				// setup the clearChat button		clearChat.addEventListener("click", Delegate.create(this, clear));		clearChat.tooltip = "Clear Chat";				// get preferences		loadProfile("videoConference");			    var my_nc:Connection = new Connection();	    my_nc.connect(red5URI);		connected = so.connect(chatID, my_nc, false);        _global.tt("Chat connected: " + connected);		//addEventListener("onNewName", Delegate.create(videoPool, videoPool.updateName));		addEventListener("newChat", Delegate.create(this, playNewChatSound));				// create sound obj		sndTarget = this.createEmptyMovieClip("sndTarget", this.getNextHighestDepth());		snd = new Sound (sndTarget);		snd.attachSound("newChatMessage");		snd.setVolume(80);				soundPlay._visible = false;		soundMute.addEventListener("click", Delegate.create(this, updateMute));		soundPlay.addEventListener("click", Delegate.create(this, updateMute));		soundMute.tooltip = "Mute new chat sound";		soundPlay.tooltip = "Un-mute new chat sound";	}		private function playNewChatSound():Void	{		if(muted) return;		snd.stop();		snd.start();	}		private function updateMute():Void	{		muted = !muted;		soundMute._visible = !muted;		soundPlay._visible = muted;	}			private function userNameChange(evtObj:Object):Void	{		LSOUserPreferences.setPreference("userName",userName.text, true);				// we put an interval on it since this is basically every keystroke.  For a local shared object, that's fine, but for Red5, that's a bit wordy		clearInterval(si);		si = setInterval(this, "updateName", 1000);	}		private function loadProfile(p_profile):Void	{		LSOUserPreferences.load(p_profile);				if(LSOUserPreferences.getPreference("userName") != undefined)		{			userName.text = LSOUserPreferences.getPreference("userName");		}else		{			userName.text = defaultUserName;		}				// tell everyone what your name is		clearInterval(si);		si = setInterval(this, "updateName", 250);	}			private function updateName():Void	{		clearInterval(si);		// tell everyone what your name is		so.sendName(userName.text, streamID);	}		private function onKeyUp():Void	{		if(Key.getCode() == 13 && message.length > 0)		{			// send message			var msg = TextFilter.encodeText(message.text);			msg = getUserName() + msg;						so.sendMessage(msg);			//so.setData(chatID, msg);						// clear text input			message.text = "";		}	}		private function getUserName():String	{		var name:String = userName.text.length > 0 ? userName.text : defaultUserName;		var value:String = "<b>" + name + "</b> - ";		return value;	}		private function clear():Void	{		// clear chat		chatBody.text = "";		history = [];		// clear doesn't work on Red5 yet		//so.clear();	}		private function onSyncHandler(evtObj:Object):Void	{		//	}		private function newNameHandler(evtObj:Object):Void	{		//_global.tt("new Name received", evtObj.name, evtObj.videoID);		dispatchEvent({type:"onNewName", name:evtObj.name, videoID:evtObj.videoID});	}		private function getNameHandler(evtObj:Object):Void	{		_global.tt("chat.getNameHandler called");		clearInterval(si);		si = setInterval(this, "updateName", 250);	}		private function newMessageHandler(evtObj:Object):Void	{		// we've been notified that there's a new message, go get it		var newChat:String = evtObj.message; //so.getData(chatID);		_global.tt("newMessage", newChat);				// return if newChat is null		if(newChat == null) return;				// push to history		history.push(newChat);				// show in chat		chatBody.text = history.join("\n");				// scroll the chat window		chatBody.vPosition = chatBody.maxVPosition;				dispatchEvent({type:"newChat"});	}}